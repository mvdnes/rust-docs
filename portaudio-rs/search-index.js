var N=null,E="",T="t",U="u",searchIndex={};
var R=["portaudio_rs","paresult","streamparameters","option","streamcallbackflags","Returns an empty set of flags.","Returns the set containing all flags.","streamflags","Returns the raw value of the flags currently stored.","from_bits","Convert from underlying bit representation, unless that…","from_bits_truncate","Convert from underlying bit representation, dropping any…","is_empty","Returns `true` if no flags are currently stored.","Returns `true` if all flags are currently set.","intersects","Returns `true` if there are flags common to both `self`…","contains","Returns `true` all of the flags in `other` are contained…","Inserts the specified flags in-place.","Removes the specified flags in-place.","Toggles the specified flags in-place.","streamcallback","paerror","stream","result","streaminfo","streamfinishedcallback","api_type","hosterrorinfo","hostapiindex","hostapiinfo","get_count","deviceindex","get_info","deviceinfo","portaudio_rs::stream","to_owned","clone_into","try_from","borrow_mut","try_into","type_id","borrow","typeid","portaudio_rs::hostapi","portaudio_rs::device","hostapitype","ordering","partial_cmp","formatter","Returns the set difference of the two sets of flags.","Returns the complement of this set of flags.","Returns the intersection between the two sets of flags.","Returns the union of the two sets of flags.","Returns the left flags, but with all the right flags…","from_iter","intoiterator","StreamTimeInfo","StreamParameters","StreamInfo","StreamCallbackResult","SampleType","StreamCallbackFlags","StreamFlags","HostApiInfo","HostErrorInfo","HostApiType","DeviceInfo"];

searchIndex[R[0]]={"doc":"PortAudio bindings for Rust","i":[[4,"PaError",R[0],"Enum for all possible errors given by PortAudio",N,N],[13,"NotInitialized",E,E,0,N],[13,"UnanticipatedHostError",E,E,0,N],[13,"InvalidChannelCount",E,E,0,N],[13,"InvalidSampleRate",E,E,0,N],[13,"InvalidDevice",E,E,0,N],[13,"InvalidFlag",E,E,0,N],[13,"SampleFormatNotSupported",E,E,0,N],[13,"BadIODeviceCombination",E,E,0,N],[13,"InsufficientMemory",E,E,0,N],[13,"BufferTooBig",E,E,0,N],[13,"BufferTooSmall",E,E,0,N],[13,"NullCallback",E,E,0,N],[13,"BadStreamPtr",E,E,0,N],[13,"TimedOut",E,E,0,N],[13,"InternalError",E,E,0,N],[13,"DeviceUnavailable",E,E,0,N],[13,"IncompatibleHostApiSpecificStreamInfo",E,E,0,N],[13,"StreamIsStopped",E,E,0,N],[13,"StreamIsNotStopped",E,E,0,N],[13,"InputOverflowed",E,E,0,N],[13,"OutputUnderflowed",E,E,0,N],[13,"HostApiNotFound",E,E,0,N],[13,"InvalidHostApi",E,E,0,N],[13,"CanNotReadFromACallbackStream",E,E,0,N],[13,"CanNotWriteToACallbackStream",E,E,0,N],[13,"CanNotReadFromAnOutputOnlyStream",E,E,0,N],[13,"CanNotWriteToAnInputOnlyStream",E,E,0,N],[13,"IncompatibleStreamHostApi",E,E,0,N],[13,"BadBufferPtr",E,E,0,N],[13,"UnknownError",E,"Added variant for when FromPrimitive returns None",0,N],[5,"initialize",E,"Initialize the PortAudio API",N,[[],[R[1]]]],[5,"terminate",E,"Terminate the PortAudio API",N,[[],[R[1]]]],[5,"version",E,"PortAudio version",N,[[],["i32"]]],[5,"version_text",E,"Human-readable PortAudio version",N,[[],["string"]]],[0,R[25],E,"Contains the Stream class and associated values",N,N],[3,R[59],R[37],"Time information for various stream related values",N,N],[12,"input_adc_time",E,"Timestamp for the ADC capture time of the first frame",1,N],[12,"current_time",E,"Timestamp that the callback was invoked",1,N],[12,"output_dac_time",E,"Timestamp for the DAC output time of the first frame",1,N],[3,R[64],E,"Flags indicating the status of the callback",N,N],[3,R[65],E,"Flags used to control the behavior of a stream",N,N],[3,"Stream",E,"An object for an PortAudio stream",N,N],[3,R[60],E,"Stream parameters to be used with Stream::open()",N,N],[12,"device",E,"Index of the device to use",2,N],[12,"channel_count",E,"Requested number of channels",2,N],[12,"suggested_latency",E,"Desired latency of the stream",2,N],[12,"data",E,"Sample data to be used in the stream",2,N],[3,R[61],E,"Information about the actual latency and sample rate…",N,N],[12,"input_latency",E,"Input latency",3,N],[12,"output_latency",E,"Output latency",3,N],[12,"sample_rate",E,"Sample rate",3,N],[4,R[62],E,"Allowable return values for a StreamCallback",N,N],[13,"Continue",E,"Continue invoking the callback",4,N],[13,"Complete",E,"Stop invoking the callback and finish once everything has…",4,N],[13,"Abort",E,"Stop invoking the callback and finish as soon as possible",4,N],[5,"is_format_supported",E,"Returns Ok when the StreamParameters are supported. This…",N,[[[R[2]],["f64"],[R[3],[R[2]]],[R[2]],[R[3],[R[2]]]],[R[1]]]],[6,"StreamCallback",E,"Callback to consume, process or generate audio",N,N],[6,"StreamFinishedCallback",E,"Callback to be fired when a StreamCallback is stopped",N,N],[17,"INPUT_UNDERFLOW",E,"Indicates that the callback has inserted one or more…",N,N],[17,"INPUT_OVERFLOW",E,"Indicates that the callback has discarded some data",N,N],[17,"OUTPUT_UNDERFLOW",E,"Indicates that extra data was inserted in the output since…",N,N],[17,"OUTPUT_OVERFLOW",E,"Indicates that certain data was discarded since there was…",N,N],[17,"PRIMING_OUTPUT",E,"Some or all of the output data will be used to prime the…",N,N],[17,"CLIP_OFF",E,"Disable clipping of out of range samples",N,N],[17,"DITHER_OFF",E,"Disable dithering",N,N],[17,"NEVER_DROP_INPUT",E,"Request that a full duplex stream will not discard…",N,N],[17,"PRIME_OUTPUT_BUFFERS_USING_STREAM_CALLBACK",E,"Call the stream callback to fill initial output buffers,…",N,N],[17,"PLATFORM_SPECIFIC",E,"Range for platform specific flags. Not all of the upper 16…",N,N],[17,"FRAMES_PER_BUFFER_UNSPECIFIED",E,"Argument to Stream::open() or Stream::open_default() to…",N,N],[8,R[63],E,"Types that are allowed to be used as samples in a Stream",N,N],[10,"sample_format",E,"Should return the PortAudio flag which corresponds to the…",5,[[],["u64"]]],[11,"empty",E,R[5],6,[[],[R[4]]]],[11,"all",E,R[6],6,[[],[R[4]]]],[11,"bits",E,R[8],6,[[["self"]],["u64"]]],[11,R[9],E,R[10],6,[[["u64"]],[[R[4]],[R[3],[R[4]]]]]],[11,R[11],E,R[12],6,[[["u64"]],[R[4]]]],[11,R[13],E,R[14],6,[[["self"]],["bool"]]],[11,"is_all",E,R[15],6,[[["self"]],["bool"]]],[11,R[16],E,R[17],6,[[[R[4]],["self"]],["bool"]]],[11,R[18],E,R[19],6,[[[R[4]],["self"]],["bool"]]],[11,"insert",E,R[20],6,[[[R[4]],["self"]]]],[11,"remove",E,R[21],6,[[[R[4]],["self"]]]],[11,"toggle",E,R[22],6,[[[R[4]],["self"]]]],[11,"empty",E,R[5],7,[[],[R[7]]]],[11,"all",E,R[6],7,[[],[R[7]]]],[11,"bits",E,R[8],7,[[["self"]],["u64"]]],[11,R[9],E,R[10],7,[[["u64"]],[[R[7]],[R[3],[R[7]]]]]],[11,R[11],E,R[12],7,[[["u64"]],[R[7]]]],[11,R[13],E,R[14],7,[[["self"]],["bool"]]],[11,"is_all",E,R[15],7,[[["self"]],["bool"]]],[11,R[16],E,R[17],7,[[["self"],[R[7]]],["bool"]]],[11,R[18],E,R[19],7,[[["self"],[R[7]]],["bool"]]],[11,"insert",E,R[20],7,[[["self"],[R[7]]]]],[11,"remove",E,R[21],7,[[["self"],[R[7]]]]],[11,"toggle",E,R[22],7,[[["self"],[R[7]]]]],[11,"open_default",E,"Constructs a stream using the default input and output…",8,[[["u32"],[R[3],["box"]],["f64"],["u64"],["box",[R[23]]]],[[R[26],[R[25],R[24]]],[R[24]],[R[25]]]]],[11,"open",E,"Constructs a stream with the desired input and output…",8,[[[R[2]],["f64"],[R[3],["box"]],[R[3],[R[2]]],[R[2]],["u64"],[R[7]],[R[3],[R[2]]],["box",[R[23]]]],[[R[26],[R[25],R[24]]],[R[24]],[R[25]]]]],[11,"start",E,"Starts the stream",8,[[["self"]],[R[1]]]],[11,"stop",E,"Stops the stream. It will block untill all audio has…",8,[[["self"]],[R[1]]]],[11,"abort",E,"Stop stream immediately without waiting for the buffers to…",8,[[["self"]],[R[1]]]],[11,"is_stopped",E,"Returns wether the stream is stopped",8,[[["self"]],[[R[26],["bool",R[24]]],["bool"],[R[24]]]]],[11,"is_active",E,"Returns wether the stream is active",8,[[["self"]],[[R[26],["bool",R[24]]],["bool"],[R[24]]]]],[11,"num_read_available",E,"Get the number of frames that can be read from the stream…",8,[[["self"]],[["u32"],[R[26],["u32",R[24]]],[R[24]]]]],[11,"num_write_available",E,"Get the number of frames that can be written to the stream…",8,[[["self"]],[["u32"],[R[26],["u32",R[24]]],[R[24]]]]],[11,"write",E,"Write the given buffer to the stream. This function blocks",8,[[["self"]],[R[1]]]],[11,"read",E,"Reads the requested number of frames from the input…",8,[[["u32"],["self"]],[["vec"],[R[26],["vec",R[24]]],[R[24]]]]],[11,"cpu_load",E,"Returns the cpu load the stream callback consumes. This…",8,[[["self"]],["f64"]]],[11,"time",E,"Get the current timestamp of the stream",8,[[["self"]],["duration"]]],[11,"info",E,"Get the actual latencies and sample rate",8,[[["self"]],[[R[27]],[R[3],[R[27]]]]]],[11,"set_finished_callback",E,"Set a callback which is to be called when the…",8,[[["box",[R[28]]],["self"],[R[28]]],[R[1]]]],[11,"unset_finished_callback",E,"Remove any previously attached finish callback",8,[[["self"]],[R[1]]]],[11,"from_i32",R[0],"Get the enum value corresponding to the given i32",0,[[["i32"]],[R[24]]]],[0,"hostapi",E,"Info module for available audio host API's",N,N],[3,R[66],R[46],"Information about a specific host API",N,N],[12,R[29],E,"The type of the API",9,N],[12,"name",E,"Human-readable name of the API",9,N],[12,"device_count",E,"Number of devices this API has",9,N],[12,"default_input",E,"Default input device of the API. Is None if there is no…",9,N],[12,"default_output",E,"Default output device of the API. Is None if there is no…",9,N],[3,R[67],E,"Error info obtained by get_last_error",N,N],[12,"code",E,"The error code given",10,N],[12,"text",E,"A human readable error message",10,N],[12,R[29],E,"The type of the API that produced the error",10,N],[4,R[68],E,"Possible Host API types",N,N],[13,"InDevelopment",E,E,11,N],[13,"DirectSound",E,E,11,N],[13,"MME",E,E,11,N],[13,"ASIO",E,E,11,N],[13,"SoundManager",E,E,11,N],[13,"CoreAudio",E,E,11,N],[13,"OSS",E,E,11,N],[13,"ALSA",E,E,11,N],[13,"AL",E,E,11,N],[13,"BeOS",E,E,11,N],[13,"WDMKS",E,E,11,N],[13,"JACK",E,E,11,N],[13,"WASAPI",E,E,11,N],[13,"AudioScienceHPI",E,E,11,N],[13,"Unknown",E,"Added for when FromPrimitive returns None",11,N],[5,"get_last_error",E,"Return information about the last host error encountered.",N,[[],[[R[30]],[R[3],[R[30]]]]]],[5,R[33],E,"Get the number of host API's available",N,[[],[["u32"],[R[26],["u32",R[24]]],[R[24]]]]],[5,"get_default_index",E,"Get the default Host API",N,[[],[[R[31]],[R[26],[R[31],R[24]]],[R[24]]]]],[5,R[35],E,"Get information about a specific Host API",N,[[[R[31]]],[[R[32]],[R[3],[R[32]]]]]],[6,"HostApiIndex",E,"Index number of a Host API",N,N],[11,"to_api_index",E,"Convert a static host API unique identifier, into a…",11,[[],[[R[31]],[R[26],[R[31],R[24]]],[R[24]]]]],[11,"from_u32",E,"Get the enum value corresponding to the u32",11,[[["u32"]],[R[48]]]],[0,"device",R[0],"Info about connected audio devices",N,N],[3,R[69],R[47],"Information for a specific device",N,N],[12,"name",E,"Human readable name",12,N],[12,"host_api",E,"Index of the host API this device belongs to",12,N],[12,"max_input_channels",E,"Maximal number of input channels that can be used",12,N],[12,"max_output_channels",E,"Maximal number of ouput channels that can be used",12,N],[12,"default_low_input_latency",E,"Default input latency for interactive performance",12,N],[12,"default_low_output_latency",E,"Default output latency for interactive performance",12,N],[12,"default_high_input_latency",E,"Default input latency for robust non-interactive…",12,N],[12,"default_high_output_latency",E,"Default output latency for robust non-interactive…",12,N],[12,"default_sample_rate",E,"Default sample rate",12,N],[5,R[33],E,"Retrieve the number of available devices.",N,[[],[["u32"],[R[26],["u32",R[24]]],[R[24]]]]],[5,"get_default_input_index",E,"Retrieve the index of the default input device",N,[[],[[R[3],[R[34]]],[R[34]]]]],[5,"get_default_output_index",E,"Retrieve the index of the default output device",N,[[],[[R[3],[R[34]]],[R[34]]]]],[5,R[35],E,"Get info about a particular device",N,[[[R[34]]],[[R[36]],[R[3],[R[36]]]]]],[5,"get_from_host_api_device_index",E,"Converts a device index from a specific host API to a…",N,[[["u32"],[R[31]]],[[R[34]],[R[26],[R[34],R[24]]],[R[24]]]]],[6,"DeviceIndex",E,"Index of a Device",N,N],[6,"PaResult",R[0],"A result type wrapping PaError.",N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,R[38],E,E,0,[[["self"]],[T]]],[11,R[39],E,E,0,[[[T],["self"]]]],[11,"to_string",E,E,0,[[["self"]],["string"]]],[11,R[40],E,E,0,[[[U]],[R[26]]]],[11,R[44],E,E,0,[[["self"]],[T]]],[11,R[43],E,E,0,[[["self"]],[R[45]]]],[11,R[41],E,E,0,[[["self"]],[T]]],[11,R[42],E,E,0,[[],[R[26]]]],[11,"from",R[37],E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[38],E,E,1,[[["self"]],[T]]],[11,R[39],E,E,1,[[[T],["self"]]]],[11,R[40],E,E,1,[[[U]],[R[26]]]],[11,R[44],E,E,1,[[["self"]],[T]]],[11,R[43],E,E,1,[[["self"]],[R[45]]]],[11,R[41],E,E,1,[[["self"]],[T]]],[11,R[42],E,E,1,[[],[R[26]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,"into",E,E,6,[[],[U]]],[11,R[38],E,E,6,[[["self"]],[T]]],[11,R[39],E,E,6,[[[T],["self"]]]],[11,R[40],E,E,6,[[[U]],[R[26]]]],[11,R[44],E,E,6,[[["self"]],[T]]],[11,R[43],E,E,6,[[["self"]],[R[45]]]],[11,R[41],E,E,6,[[["self"]],[T]]],[11,R[42],E,E,6,[[],[R[26]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,"into",E,E,7,[[],[U]]],[11,R[38],E,E,7,[[["self"]],[T]]],[11,R[39],E,E,7,[[[T],["self"]]]],[11,R[40],E,E,7,[[[U]],[R[26]]]],[11,R[44],E,E,7,[[["self"]],[T]]],[11,R[43],E,E,7,[[["self"]],[R[45]]]],[11,R[41],E,E,7,[[["self"]],[T]]],[11,R[42],E,E,7,[[],[R[26]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,"into",E,E,8,[[],[U]]],[11,R[40],E,E,8,[[[U]],[R[26]]]],[11,R[44],E,E,8,[[["self"]],[T]]],[11,R[43],E,E,8,[[["self"]],[R[45]]]],[11,R[41],E,E,8,[[["self"]],[T]]],[11,R[42],E,E,8,[[],[R[26]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[38],E,E,2,[[["self"]],[T]]],[11,R[39],E,E,2,[[[T],["self"]]]],[11,R[40],E,E,2,[[[U]],[R[26]]]],[11,R[44],E,E,2,[[["self"]],[T]]],[11,R[43],E,E,2,[[["self"]],[R[45]]]],[11,R[41],E,E,2,[[["self"]],[T]]],[11,R[42],E,E,2,[[],[R[26]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[],[U]]],[11,R[38],E,E,3,[[["self"]],[T]]],[11,R[39],E,E,3,[[[T],["self"]]]],[11,R[40],E,E,3,[[[U]],[R[26]]]],[11,R[44],E,E,3,[[["self"]],[T]]],[11,R[43],E,E,3,[[["self"]],[R[45]]]],[11,R[41],E,E,3,[[["self"]],[T]]],[11,R[42],E,E,3,[[],[R[26]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"into",E,E,4,[[],[U]]],[11,R[38],E,E,4,[[["self"]],[T]]],[11,R[39],E,E,4,[[[T],["self"]]]],[11,R[40],E,E,4,[[[U]],[R[26]]]],[11,R[44],E,E,4,[[["self"]],[T]]],[11,R[43],E,E,4,[[["self"]],[R[45]]]],[11,R[41],E,E,4,[[["self"]],[T]]],[11,R[42],E,E,4,[[],[R[26]]]],[11,"from",R[46],E,9,[[[T]],[T]]],[11,"into",E,E,9,[[],[U]]],[11,R[40],E,E,9,[[[U]],[R[26]]]],[11,R[44],E,E,9,[[["self"]],[T]]],[11,R[43],E,E,9,[[["self"]],[R[45]]]],[11,R[41],E,E,9,[[["self"]],[T]]],[11,R[42],E,E,9,[[],[R[26]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,"into",E,E,10,[[],[U]]],[11,R[40],E,E,10,[[[U]],[R[26]]]],[11,R[44],E,E,10,[[["self"]],[T]]],[11,R[43],E,E,10,[[["self"]],[R[45]]]],[11,R[41],E,E,10,[[["self"]],[T]]],[11,R[42],E,E,10,[[],[R[26]]]],[11,"from",E,E,11,[[[T]],[T]]],[11,"into",E,E,11,[[],[U]]],[11,R[38],E,E,11,[[["self"]],[T]]],[11,R[39],E,E,11,[[[T],["self"]]]],[11,R[40],E,E,11,[[[U]],[R[26]]]],[11,R[44],E,E,11,[[["self"]],[T]]],[11,R[43],E,E,11,[[["self"]],[R[45]]]],[11,R[41],E,E,11,[[["self"]],[T]]],[11,R[42],E,E,11,[[],[R[26]]]],[11,"from",R[47],E,12,[[[T]],[T]]],[11,"into",E,E,12,[[],[U]]],[11,R[40],E,E,12,[[[U]],[R[26]]]],[11,R[44],E,E,12,[[["self"]],[T]]],[11,R[43],E,E,12,[[["self"]],[R[45]]]],[11,R[41],E,E,12,[[["self"]],[T]]],[11,R[42],E,E,12,[[],[R[26]]]],[11,"eq",R[37],E,6,[[[R[4]],["self"]],["bool"]]],[11,"ne",E,E,6,[[[R[4]],["self"]],["bool"]]],[11,"eq",E,E,7,[[["self"],[R[7]]],["bool"]]],[11,"ne",E,E,7,[[["self"],[R[7]]],["bool"]]],[11,"eq",R[0],E,0,[[[R[24]],["self"]],["bool"]]],[11,"clone",R[37],E,4,[[["self"]],["streamcallbackresult"]]],[11,"clone",E,E,1,[[["self"]],["streamtimeinfo"]]],[11,"clone",E,E,6,[[["self"]],[R[4]]]],[11,"clone",E,E,7,[[["self"]],[R[7]]]],[11,"clone",E,E,2,[[["self"]],[R[2]]]],[11,"clone",E,E,3,[[["self"]],[R[27]]]],[11,"clone",R[0],E,0,[[["self"]],[R[24]]]],[11,"clone",R[46],E,11,[[["self"]],[R[48]]]],[11,"cmp",R[37],E,6,[[[R[4]],["self"]],[R[49]]]],[11,"cmp",E,E,7,[[["self"],[R[7]]],[R[49]]]],[11,"drop",E,E,8,[[["self"]]]],[11,R[50],E,E,6,[[[R[4]],["self"]],[[R[49]],[R[3],[R[49]]]]]],[11,"lt",E,E,6,[[[R[4]],["self"]],["bool"]]],[11,"le",E,E,6,[[[R[4]],["self"]],["bool"]]],[11,"gt",E,E,6,[[[R[4]],["self"]],["bool"]]],[11,"ge",E,E,6,[[[R[4]],["self"]],["bool"]]],[11,R[50],E,E,7,[[["self"],[R[7]]],[[R[49]],[R[3],[R[49]]]]]],[11,"lt",E,E,7,[[["self"],[R[7]]],["bool"]]],[11,"le",E,E,7,[[["self"],[R[7]]],["bool"]]],[11,"gt",E,E,7,[[["self"],[R[7]]],["bool"]]],[11,"ge",E,E,7,[[["self"],[R[7]]],["bool"]]],[11,"fmt",E,E,6,[[["self"],[R[51]]],[R[26]]]],[11,"fmt",E,E,7,[[["self"],[R[51]]],[R[26]]]],[11,"fmt",R[0],E,0,[[[R[51]],["self"]],[[R[26],["error"]],["error"]]]],[11,"fmt",E,E,0,[[[R[51]],["self"]],[[R[26],["error"]],["error"]]]],[11,"hash",R[37],E,6,[[["self"],["__h"]]]],[11,"hash",E,E,7,[[["self"],["__h"]]]],[11,"sub",E,R[52],6,[[[R[4]]],[R[4]]]],[11,"sub",E,R[52],7,[[[R[7]]],[R[7]]]],[11,"not",E,R[53],6,[[],[R[4]]]],[11,"not",E,R[53],7,[[],[R[7]]]],[11,"bitand",E,R[54],6,[[[R[4]]],[R[4]]]],[11,"bitand",E,R[54],7,[[[R[7]]],[R[7]]]],[11,"bitor",E,R[55],6,[[[R[4]]],[R[4]]]],[11,"bitor",E,R[55],7,[[[R[7]]],[R[7]]]],[11,"bitxor",E,R[56],6,[[[R[4]]],[R[4]]]],[11,"bitxor",E,R[56],7,[[[R[7]]],[R[7]]]],[11,R[57],E,E,6,[[[R[58]]],[R[4]]]],[11,R[57],E,E,7,[[[R[58]]],[R[7]]]]],"p":[[4,"PaError"],[3,R[59]],[3,R[60]],[3,R[61]],[4,R[62]],[8,R[63]],[3,R[64]],[3,R[65]],[3,"Stream"],[3,R[66]],[3,R[67]],[4,R[68]],[3,R[69]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);