var N=null,E="",T="t",U="u",searchIndex={};
var R=["mutexguard","Creates a new spinlock wrapping the supplied data.","into_inner","rwlockreadguard","option","rwlockwriteguard","rwlockupgradeableguard","get_mut","Returns a mutable reference to the underlying data.","downgrade","try_from","try_into","result","borrow_mut","type_id","borrow","typeid","deref_mut","formatter","RwLockUpgradeableGuard","RwLockWriteGuard","MutexGuard","RwLockReadGuard"];

searchIndex["spin"]={"doc":"Synchronization primitives based on spinning","i":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",N,N],[3,R[21],E,"A guard to which the protected data can be accessed",N,N],[3,"RwLock",E,"A reader-writer lock",N,N],[3,R[22],E,"A guard from which the protected data can be read",N,N],[3,R[20],E,"A guard to which the protected data can be written",N,N],[3,R[19],E,"A guard from which the protected data can be read, and can…",N,N],[3,"Once",E,"A synchronization primitive which can be used to run a…",N,N],[11,"new",E,R[1],0,[[[T]],["mutex"]]],[11,R[2],E,"Consumes this mutex, returning the underlying data.",0,[[],[T]]],[11,"lock",E,"Locks the spinlock and returns a guard.",0,[[["self"]],[R[0]]]],[11,"force_unlock",E,"Force unlock the spinlock.",0,[[["self"]]]],[11,"try_lock",E,"Tries to lock the mutex. If it is already locked, it will…",0,[[["self"]],[[R[0]],[R[4],[R[0]]]]]],[11,R[7],E,R[8],0,[[["self"]],[T]]],[11,"new",E,R[1],1,[[[T]],["rwlock"]]],[11,R[2],E,"Consumes this `RwLock`, returning the underlying data.",1,[[],[T]]],[11,"read",E,"Locks this rwlock with shared read access, blocking the…",1,[[["self"]],[R[3]]]],[11,"try_read",E,"Attempt to acquire this lock with shared read access.",1,[[["self"]],[[R[3]],[R[4],[R[3]]]]]],[11,"force_read_decrement",E,"Force decrement the reader count.",1,[[["self"]]]],[11,"force_write_unlock",E,"Force unlock exclusive write access.",1,[[["self"]]]],[11,"write",E,"Lock this rwlock with exclusive write access, blocking the…",1,[[["self"]],[R[5]]]],[11,"try_write",E,"Attempt to lock this rwlock with exclusive write access.",1,[[["self"]],[[R[5]],[R[4],[R[5]]]]]],[11,"upgradeable_read",E,"Obtain a readable lock guard that can later be upgraded to…",1,[[["self"]],[R[6]]]],[11,"try_upgradeable_read",E,"Tries to obtain an upgradeable lock guard.",1,[[["self"]],[[R[6]],[R[4],[R[6]]]]]],[11,R[7],E,R[8],1,[[["self"]],[T]]],[11,"upgrade",E,"Upgrades an upgradeable lock guard to a writable lock guard.",2,[[],[R[5]]]],[11,"try_upgrade",E,"Tries to upgrade an upgradeable lock guard to a writable…",2,[[],[[R[5]],[R[12],[R[5]]]]]],[11,R[9],E,"Downgrades the upgradeable lock guard to a readable,…",2,[[],[R[3]]]],[11,R[9],E,"Downgrades the writable lock guard to a readable, shared…",3,[[],[R[3]]]],[18,"INIT",E,"Initialization constant of `Once`.",4,N],[11,"new",E,"Creates a new `Once` value.",4,[[],["once"]]],[11,"call_once",E,"Performs an initialization routine once and only once. The…",4,[[["self"],["f"]],[T]]],[11,"try",E,"Returns a pointer iff the `Once` was previously initialized",4,[[["self"]],[[T],[R[4]]]]],[11,"wait",E,"Like try, but will spin if the `Once` is in the process of…",4,[[["self"]],[[T],[R[4]]]]],[11,R[10],E,E,0,[[[U]],[R[12]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[11],E,E,0,[[],[R[12]]]],[11,R[15],E,E,0,[[["self"]],[T]]],[11,R[13],E,E,0,[[["self"]],[T]]],[11,R[14],E,E,0,[[["self"]],[R[16]]]],[11,R[10],E,E,5,[[[U]],[R[12]]]],[11,"into",E,E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[11],E,E,5,[[],[R[12]]]],[11,R[15],E,E,5,[[["self"]],[T]]],[11,R[13],E,E,5,[[["self"]],[T]]],[11,R[14],E,E,5,[[["self"]],[R[16]]]],[11,R[10],E,E,1,[[[U]],[R[12]]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[11],E,E,1,[[],[R[12]]]],[11,R[15],E,E,1,[[["self"]],[T]]],[11,R[13],E,E,1,[[["self"]],[T]]],[11,R[14],E,E,1,[[["self"]],[R[16]]]],[11,R[10],E,E,6,[[[U]],[R[12]]]],[11,"into",E,E,6,[[],[U]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[11],E,E,6,[[],[R[12]]]],[11,R[15],E,E,6,[[["self"]],[T]]],[11,R[13],E,E,6,[[["self"]],[T]]],[11,R[14],E,E,6,[[["self"]],[R[16]]]],[11,R[10],E,E,3,[[[U]],[R[12]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[11],E,E,3,[[],[R[12]]]],[11,R[15],E,E,3,[[["self"]],[T]]],[11,R[13],E,E,3,[[["self"]],[T]]],[11,R[14],E,E,3,[[["self"]],[R[16]]]],[11,R[10],E,E,2,[[[U]],[R[12]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[11],E,E,2,[[],[R[12]]]],[11,R[15],E,E,2,[[["self"]],[T]]],[11,R[13],E,E,2,[[["self"]],[T]]],[11,R[14],E,E,2,[[["self"]],[R[16]]]],[11,R[10],E,E,4,[[[U]],[R[12]]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[11],E,E,4,[[],[R[12]]]],[11,R[15],E,E,4,[[["self"]],[T]]],[11,R[13],E,E,4,[[["self"]],[T]]],[11,R[14],E,E,4,[[["self"]],[R[16]]]],[11,"deref",E,E,5,[[["self"]],[T]]],[11,"deref",E,E,6,[[["self"]],[T]]],[11,"deref",E,E,2,[[["self"]],[T]]],[11,"deref",E,E,3,[[["self"]],[T]]],[11,R[17],E,E,5,[[["self"]],[T]]],[11,R[17],E,E,3,[[["self"]],[T]]],[11,"fmt",E,E,5,[[["self"],[R[18]]],[R[12]]]],[11,"fmt",E,E,0,[[["self"],[R[18]]],[R[12]]]],[11,"fmt",E,E,6,[[["self"],[R[18]]],[R[12]]]],[11,"fmt",E,E,3,[[["self"],[R[18]]],[R[12]]]],[11,"fmt",E,E,2,[[["self"],[R[18]]],[R[12]]]],[11,"fmt",E,E,1,[[["self"],[R[18]]],[R[12]]]],[11,"fmt",E,E,4,[[["self"],[R[18]]],[R[12]]]],[11,"drop",E,"The dropping of the MutexGuard will release the lock it…",5,[[["self"]]]],[11,"drop",E,E,6,[[["self"]]]],[11,"drop",E,E,2,[[["self"]]]],[11,"drop",E,E,3,[[["self"]]]],[11,"default",E,E,0,[[],["mutex"]]],[11,"default",E,E,1,[[],["rwlock"]]]],"p":[[3,"Mutex"],[3,"RwLock"],[3,R[19]],[3,R[20]],[3,"Once"],[3,R[21]],[3,R[22]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);