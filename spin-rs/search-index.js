var N = null;var searchIndex = {};
searchIndex["spin"]={"doc":"Synchronization primitives based on spinning","items":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",N,N],[3,"MutexGuard","","A guard to which the protected data can be accessed",N,N],[3,"RwLock","","A reader-writer lock",N,N],[3,"RwLockReadGuard","","A guard to which the protected data can be read",N,N],[3,"RwLockWriteGuard","","A guard to which the protected data can be written",N,N],[3,"Once","","A synchronization primitive which can be used to run a one-time global initialization. Unlike its std equivalent, this is generalized so that The closure returns a value and it is stored. Once therefore acts something like 1a future, too.",N,N],[11,"new","","Creates a new spinlock wrapping the supplied data.",0,[[["t"]],["mutex"]]],[11,"into_inner","","Consumes this mutex, returning the underlying data.",0,[[["self"]],["t"]]],[11,"lock","","Locks the spinlock and returns a guard.",0,[[["self"]],["mutexguard"]]],[11,"force_unlock","","Force unlock the spinlock.",0,[[["self"]]]],[11,"try_lock","","Tries to lock the mutex. If it is already locked, it will return None. Otherwise it returns a guard within Some.",0,[[["self"]],["option",["mutexguard"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"default","","",0,[[],["mutex"]]],[11,"deref","","",1,[[["self"]],["t"]]],[11,"deref_mut","","",1,[[["self"]],["t"]]],[11,"drop","","The dropping of the MutexGuard will release the lock it was created from.",1,[[["self"]]]],[11,"new","","Creates a new spinlock wrapping the supplied data.",2,[[["t"]],["rwlock"]]],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",2,[[["self"]],["t"]]],[11,"read","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",2,[[["self"]],["rwlockreadguard"]]],[11,"try_read","","Attempt to acquire this lock with shared read access.",2,[[["self"]],["option",["rwlockreadguard"]]]],[11,"force_read_decrement","","Force decrement the reader count.",2,[[["self"]]]],[11,"force_write_unlock","","Force unlock exclusive write access.",2,[[["self"]]]],[11,"write","","Lock this rwlock with exclusive write access, blocking the current thread until it can be acquired.",2,[[["self"]],["rwlockwriteguard"]]],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",2,[[["self"]],["option",["rwlockwriteguard"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"default","","",2,[[],["rwlock"]]],[11,"deref","","",3,[[["self"]],["t"]]],[11,"deref","","",4,[[["self"]],["t"]]],[11,"deref_mut","","",4,[[["self"]],["t"]]],[11,"drop","","",3,[[["self"]]]],[11,"drop","","",4,[[["self"]]]],[11,"new","","Creates a new `Once` value.",5,[[],["once"]]],[11,"call_once","","Performs an initialization routine once and only once. The given closure will be executed if this is the first time `call_once` has been called, and otherwise the routine will not be invoked.",5,[[["self"],["f"]],["t"]]],[11,"try","","Returns a pointer iff the `Once` was previously initialized",5,[[["self"]],["option"]]],[11,"wait","","Like try, but will spin if the `Once` is in the process of being initialized",5,[[["self"]],["option"]]]],"paths":[[3,"Mutex"],[3,"MutexGuard"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"Once"]]};
initSearch(searchIndex);
